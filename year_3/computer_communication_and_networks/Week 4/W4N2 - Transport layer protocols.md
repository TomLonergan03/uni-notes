Transport layer protocols provide **logical communication** between processes running on different hosts. Logical communication means that from the application layer's perspective, it is as if the hosts are directly connected, even if in reality they are on opposite sides of the planet connected by a variety of [[W1N2 - Network edge#Physical media|link types]] and a number of [[W2N1 - Network core#Packet switching|switches and routers]]. An application will pass data to the transport layer, which then breaks it into smaller chunks and wraps each chunk with a transport layer header to create a transport layer **segment**. This segment is then passed to the network layer at the sending system where it is wrapped in network layer headers and sent to its destination. Network routers act only on the network headers, and do not touch the transport layer header or data. The network layer provides logical communication between *hosts*, which is a subtle but important difference to the transport layer.

The services a transport layer protocol can provide are constrained by what the network layer can do (e.g. if the network layer has no upper bound on delivery times the transport layer cannot do so either), but it can still provide services that the network layer doesn't, (e.g. it is possible to ensure reliable data transfer even if the network itself is unreliable). Similarly, a transport protocol could use encryption to guarantee that application messages aren't read by intruders, even if the network layer cannot guarantee the confidentiality of transport layer segments.
# Transport layer multiplexing
At the application layer, messages are sent to a specific application. At the network layer, a datagram is sent to a host. This means that the receiving transport layer must determine what application each segment is meant to be delivered to - this is **demultiplexing**. Demultiplexing uses information in the segment header to determine what [[W3N1 - Network applications#Sockets|socket]] that segment is meant to go to, and that data is encoded into the header by the sending transport layer during **multiplexing**.
## UDP multiplexing
UDP simply uses a [[W3N1 - Network applications#Ports|port number]] bound to each socket, and each UDP socket is purely identified using a two tuple (destination IP address, destination port number). The UDP header still contains a source IP address and port number, which is used as a return address, so the recipient can respond to that packet.
## TCP multiplexing
A TCP socket is identified by a four tuple (source IP, source port number, destination IP, destination port number). This means that TCP segments from many different hosts may arrive at the same host with the same port number, but each segment is routed to a different socket.
### TCP sockets and webservers
As a TCP socket is unique to the four-tuple, there must be a different socket for each client who attempts to connect to a webserver. The modern way of doing this is to create a new [[W4N1 - Threads|thread]] for each incoming TCP request. This creation and destruction of threads is a substantial cost for webservers, and is another reason why [[W3N5 - The Web and HTTP#Non-persistent and persistent connections|persistent connections]] are preferred.